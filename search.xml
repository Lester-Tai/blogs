<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解Java线程</title>
      <link href="/blogs/2021/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/"/>
      <url>/blogs/2021/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解Java线程"><a href="#深入理解Java线程" class="headerlink" title="深入理解Java线程"></a>深入理解Java线程</h1><p>[toc]</p><h2 id="线程基础知识"><a href="#线程基础知识" class="headerlink" title="线程基础知识"></a>线程基础知识</h2><p>回顾: 程序在计算机上是如何执行的?</p><h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><blockquote><p><strong>进程</strong></p><ul><li>程序由指令和数据组成, 但这些指令要运行, 数据要读写, 就必须将指令加载至CPU, 数据加载至内存. 在指令运行过程中还需要用到磁盘、网络等设备.<font color="red"><strong>进程就是用来加载指令、管理内存、管理IO的</strong></font></li><li>当一个程序被运行, 从磁盘加载这个程序的代码至内存, 这时就开启了一个进程.</li><li>进程就可以视为程序的一个实例. 大部分程序可以同时运行多个实例进程(例如记事本、画图、浏览器等), 也有的程序只能启动一个实例进程(例如网易云音乐、360安全卫士等).</li><li><strong>操作系统会以进程为单位, 分配系统资源(CPU时间片、内存等资源), <font color="red">进程是资源分配的最小单位</font></strong></li></ul></blockquote><blockquote><p><strong>线程</strong></p><ul><li>线程是进程中的实体, 一个进程可以拥有多个线程, 一个线程必须有一个父进程.</li><li>一个线程就是一个指令流, 将指令流中的一条条指令以一定的顺序交给CPU执行.</li><li><strong>线程有时被称为轻量级进程(Lightweight Process, LWP), <font color="red">是操作系统调度(CPU调度)执行的最小单位</font></strong></li></ul></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9eeaf89d24b338f1aab4205e74562a0a?method=download&shareKey=2c189cde9989c4f4df24d44d327c48f1" alt="avatar">  </p><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ul><li>进程基本上相互独立, 而线程存在于进程内, 是进程的一个子集</li><li>进程拥有共享的资源, 如内存空间等, 供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为IPC(Inter-process communication)</li><li>不同计算机之间的进程通讯, 需要通过网络, 并遵守共同的协议, 例如HTTP</li></ul></li><li>线程通讯相对简单, 因为它们共享进程内的内存, 一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量, 线程上下文切换成本一般上要比进程上下文切换低</li></ul><h4 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h4><ol><li><strong>管道(pipe)及有名管道(named pipe): </strong><br>管道可用于具有亲缘关系的父子进程间的通信, 有名管道除了具有管道所具有的功能外, 它还允许无亲缘关系进程间的通信.</li><li><strong>信号(signal): </strong><br>信号是再软件层次上对中断机制的一种模拟, 它是比较复杂的通信方式, 用于通知进程有某事件发生, 一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的.</li><li><strong>消息队列(message queue): </strong><br>消息队列是消息的链接表, 它克服了上两种通信方式中信号量有限的缺点, 具有写权限的进程可以按照一定的规则向消息队列中添加新信息; 对消息队列有读权限得进程则可以从消息队列中读取信息.</li><li><strong>共享内存(shared memory): </strong><br>可以说这是最有用的进程间通信方式. 它使得多个进程可以访问同一块内存空间, 不同进程可以及时看到对方进程中对共享内存中数据得更新. 这种方式需要依靠某种同步操作, 如互斥锁和信号量等.</li><li><strong>信号量(semaphore): </strong><br>主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段.</li><li><strong>套接字(socket): </strong><br>这是一种更为一般的进程间通信机制, 它可用于网络中不同机器之间的进程间通信, 应用非常广泛.</li></ol><h3 id="线程的同步互斥"><a href="#线程的同步互斥" class="headerlink" title="线程的同步互斥"></a>线程的同步互斥</h3><ul><li><strong>线程同步</strong><br>是指线程之间所具有的一种制约关系, 一个线程的执行依赖另一个线程的消息, 当它没有得到另一个线程的消息时等待, 直到消息到达时才被唤醒.</li><li><strong>线程互斥</strong><br><strong>是指对于共享的进程系统资源, 在各单个线程访问时的排他性.</strong>当有若干个线程都要使用某一共享资源时, 任何时刻最多只允许一个线程去使用, 其他要使用该资源的线程必须等待, 直到占用资源者释放该资源. 线程互斥可以看成是一种特殊的线程同步.</li></ul><h4 id="4种线程同步互斥的控制方法"><a href="#4种线程同步互斥的控制方法" class="headerlink" title="4种线程同步互斥的控制方法"></a>4种线程同步互斥的控制方法</h4><ul><li><strong>临界区: </strong>通过对多线程的串行化来访问公共资源或一段代码, 速度快, 适合控制数据访问. (在一段时间内只允许一个线程访问的资源就称为临界资源).</li><li><strong>互斥量: </strong>为协调共同对一个共享资源的单独访问而设计的.</li><li><strong>信号量: </strong>为控制一个具有有限数量用户资源而设计</li><li><strong>事件: </strong>用来通知线程有一些事件已发生, 从而启动后继任务的开始.</li></ul><h3 id="上下文切换-Context-switch"><a href="#上下文切换-Context-switch" class="headerlink" title="上下文切换(Context switch)"></a>上下文切换(Context switch)</h3><p>上下文切换是指CPU从一个进程或线程到另一个进程或线程的切换.  </p><blockquote><p>进程是程序的一个执行实例. 在Linux中, 线程是轻量级进程, 可以并行运行, 并与父进程(即创建线程的进程)共享一个地址空间和其他资源.<br>上下文是CPU寄存器和程序计数器在任何时间点的内容.<br>寄存器是CPU内部的一小部分非常快的内存(相对于CPU外部较慢的RAM主内存), 它通过提供对常用值的快速访问来加快计算机程序的执行.<br>程序计数器是一种专门的寄存器, 它指示CPU在其指令序列中的位置, 并保存着正在执行的指令的地址或下一条要执行的指令的地址, 这取决于具体的系统.</p></blockquote><p><img src="https://note.youdao.com/yws/api/personal/file/WEB115e3e70fd1970479f216a111e17f519?method=download&shareKey=095ce676341d4f76cf726bc8f5f39073" alt="avatar">  </p><p>上下文切换可以更详细地描述为内核(即操作系统的核心)对CPU上的进程(包括线程)执行以下活动:  </p><ol><li>暂停一个进程的处理, 并将该进程的CPU状态(即上下文)存储在内存中的某个地方</li><li>从内存中获取下一个进程的上下文, 并在CPU的寄存器中恢复它</li><li>返回到程序计数器指示的位置(即返回到进程被中断的代码行)以恢复进程</li></ol><p><img src="https://note.youdao.com/yws/api/personal/file/WEBeb7038e70087e72d583b00360f5df59b?method=download&shareKey=ebdaacfdf3d8293b75ff7e5a08a5a688" alt="avatar">  </p><p><font color="red"><strong>上下文切换只能再内核模式下发生.</strong></font> 内核模式是CPU的特权模式, 其中只有内核运行, 并提供对所有内存位置和所有其他系统资源的访问. 其他程序(包括应用程序)最初在用户模式下运行, 但它们可以通过系统调用运行部分内核代码.  </p><p><font color="red"><strong>上下文切换是多任务操作系统的一个基本特性.</strong></font> 在多任务操作系统中, 多个进程似乎同时再一个CPU上执行, 彼此之间互不干扰. 这种并发的错觉是通过快速连续发生的上下文切换(每秒数十次或数百次)来实现的. 这些上下文切换发生的原因是进程自愿放弃它们在CPU中的时间, 或者是调度器在进程耗尽其CPU时间片时进行切换的结果.  </p><p>上下文切换通常是计算密集型的. 就CPU时间而言, 上下文切换对系统来说是一个巨大的成本, 实际上, 它可能是操作系统上成本最高的操作. 因此, 操作系统设计中的一个主要焦点是<font color="red">**尽可能地避免不必要的上下文切换. **</font> 与其他操作系统(包括一些其他类unix系统)相比, Linux的众多优势之一是它的上下文切换和模式切换成本极低.  </p><h4 id="通过命令查看CPU上下文切换情况"><a href="#通过命令查看CPU上下文切换情况" class="headerlink" title="通过命令查看CPU上下文切换情况"></a>通过命令查看CPU上下文切换情况</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 操作系统每一秒CPU上下文切换的统计</span></span><br><span class="line">vmstat 1</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/WEB9c02e5cd80ef65124d6fd7d520d68ca2?method=download&shareKey=63c648e2f1e0822a1d51e2647a3d6f6b" alt="avatar">  </p><p>其中cs列就是CPU上下文切换的统计. 当然, <strong>CPU上下文切换不等价于线程切换</strong>, 很多操作会造成CPU上下文切换:   </p><ul><li>线程、进程切换</li><li>系统调用</li><li>中断</li></ul><h4 id="查看某一个线程-进程的上下文切换"><a href="#查看某一个线程-进程的上下文切换" class="headerlink" title="查看某一个线程/进程的上下文切换"></a>查看某一个线程/进程的上下文切换</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常用参数:</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> -u 默认参数, 显示各个进程的CPU统计信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -r 显示各个进程的内存使用情况</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 显示各个进程的IO使用</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -w 显示各个进程的上下文切换</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p PID 指定PID</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看5598每一秒的切换情况</span></span><br><span class="line">pidstat -w -p 5598</span><br></pre></td></tr></table></figure><p><img src="https://note.youdao.com/yws/api/personal/file/WEB57ec7f70d0cd579e1663ddc1cd4e4a77?method=download&shareKey=a6ea3ece2de6db811f9dd3614e6e77f7" alt="avatar">  </p><p>其中cswch表示主动切换, nvcswch表示被动切换. 从统计数据中看到, 该进程每秒主动切换次数达到将近500次, 因此代码中存在大量的 <strong>睡眠/唤醒</strong> 操作.  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看进程的状态信息</span></span><br><span class="line">cat /proc/5598/status</span><br></pre></td></tr></table></figure><blockquote><p><strong>该进程从启动到当前总的上下文切换情况</strong><br>voluntary_ctxt_switches: 40469351<br>nonvoluntary_ctxt_switches: 2268  </p></blockquote><h3 id="操作系统层面线程生命周期"><a href="#操作系统层面线程生命周期" class="headerlink" title="操作系统层面线程生命周期"></a>操作系统层面线程生命周期</h3><p>操作系统层面的线程生命周期基本上可以用下图这个<code>五态模型</code>来描述.<br><img src="https://note.youdao.com/yws/api/personal/file/WEB324b1e8ef8d124dc828c6c48c13e520f?method=download&shareKey=00f892bc8e7776b91e0433837b0cb574" alt="avatar">  </p><ol><li><strong>初始状态</strong><br>指的是线程已经被创建, 但是还不允许分配CPU执行. 这个状态属于编程语言特有的, 不过这里所谓的被创建, 仅仅是再编程语言层面被创建, 而在操作系统层面, 真正的线程还没有被创建. </li><li><strong>可运行状态</strong><br>指的是线程可以分配CPU执行. 这种状态下, 真正的操作系统线程已经被成功创建了, 所以可以分配CPU执行. </li><li><strong>运行状态</strong><br>当有空闲的CPU时, 操作系统会将其分配给一个处于可运行状态的线程, 被分配到CPU的线程的状态就转换成了运行状态. </li><li><strong>休眠状态</strong><br>运行状态的线程如果调用一个阻塞的API(例如以阻塞方式读文件)或者等待某个事件(例如条件变量), 那么线程的状态就会转换到休眠状态, 同时释放CPU使用权, 休眠状态的线程永远没有机会获得CPU使用权. 当等待的事件出现了, 线程就会从休眠状态转换回可运行状态. </li><li><strong>终止状态</strong><br>线程执行完或者出现异常就会进入终止状态, 终止状态的线程不会切换到其他任何状态, 进入终止状态也就意味着线程的生命周期结束了. </li></ol><p>这五种状态在不同编程语言里会有简化合并. 例如, C语言的POSIX Threads规范, 就把初始状态和可运行状态合并了; Java语言里则把可运行状态和运行状态合并了, 这两个状态在操作系统调度层面有用, 而JVM层面不关心这两个状态, 因为JVM把线程调度交给操作系统处理了. </p><h4 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h4><blockquote><p><strong>windows</strong>  </p><ul><li>任务管理器可以查看进程和线程数, 也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul></blockquote><blockquote><p><strong>linux</strong>  </p><ul><li>ps -ef 查看所有进程</li><li>ps -fT -p <PID> 查看某个进程的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p <PID> 查看某个进程的所有线程</li></ul></blockquote><blockquote><p><strong>java</strong>  </p><ul><li>jps 查看所有Java进程</li><li>jstack <PID> 查看某个Java进程的所有线程状态</li><li>jconsole 查看某个Java进程中线程的运行情况</li></ul></blockquote><h4 id="Linux系统中线程实现方式"><a href="#Linux系统中线程实现方式" class="headerlink" title="Linux系统中线程实现方式"></a>Linux系统中线程实现方式</h4><ul><li>LinuxThreads<br>linux/glibc包在2.3.2之前只实现了LinuxThreads</li><li>NPTL(Native POSIX Thread Library)</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统使用哪种线程实现</span></span><br><span class="line">getconf GNU_LIBPTHREAD_VERSION</span><br></pre></td></tr></table></figure><h2 id="Java线程详解"><a href="#Java线程详解" class="headerlink" title="Java线程详解"></a>Java线程详解</h2><h3 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h3><p>思考: Java中实现线程有几种方式?</p><ol><li><strong>使用Thread类或继承Thread类</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 待执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure></li><li><strong>实现Runnable接口配合Thread</strong><br>把<code>线程</code>和<code>任务</code>分开</li></ol><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 待执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line"><span class="comment">// 启动线程</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>使用有返回值的Callable<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService service= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 提交任务, 并用Future提交返回结果</span></span><br></pre></td></tr></table></figure></li><li>使用lambda<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br></pre></td></tr></table></figure></li></ol><p><strong>本质上Java中实现线程只有一种方式, 都是通过new Thread()创建线程, 调用Thread#start启动线程最终都会调用Thread#run方法</strong></p><h3 id="Java线程实现原理"><a href="#Java线程实现原理" class="headerlink" title="Java线程实现原理"></a>Java线程实现原理</h3><p>思考: Java线程执行为什么不能直接调用run()方法, 而要调用start()方法?</p><h4 id="Thread-start-源码分析"><a href="#Thread-start-源码分析" class="headerlink" title="Thread#start()源码分析"></a>Thread#start()源码分析</h4><p><a href="https://www.processon.com/view/link/61a31bb4e401fd48c0b5105a">https://www.processon.com/view/link/61a31bb4e401fd48c0b5105a</a>  </p><h4 id="Java线程属于内核级线程"><a href="#Java线程属于内核级线程" class="headerlink" title="Java线程属于内核级线程"></a>Java线程属于内核级线程</h4><p>JDK1.2 – 基于操作系统原生线程模型来实现. Sun JDK, 它的Windows版本和Linux版本都是使用一对一的线程模型实现, 一条Java线程就映射到一条轻量级进程之中.<br><strong>内核级线程(Kernel Level Thread, KLT):</strong> 它们时依赖于内核的, 即无论时用户进程中的线程, 还是系统进程中的线程, 它们的创建、撤销、切换都由内核实现.<br><strong>用户级线程(User Level Thread, ULT):</strong> 操作系统内核不知道应用线程的存在.  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBab14fc8e2011c4ee67330390db49865e?method=download&shareKey=9e0cce5de9d9f8fff750d81a7f49df68" alt="avatar">  </p><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><p>协程(Coroutines), 是一种基于线程之上, 但又比线程更加轻量级的存在, 协程是不被操作系统内核所管理, 而完全是由程序锁控制(也就是在用户态执行), 具有对内核来说不可见的特性. 这样带来的好处就是性能得到了很大的提升, 不会像线程切换那样消耗资源.  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB4edfcc9d6436ad542a652515940ca310?method=download&shareKey=70716aa50a9c0e1a67eca9d6d6d028a9" alt="avatar">  </p><p>子程序, 或者称为函数, 在所有语言中都是层级调用, 比如A调用B, B在执行过程中又调用了C, C执行完毕返回, B执行完毕返回, 最后时A执行完毕. 而协程的调用和子程序不同. 协程在子程序内部是可中断的, 然后转而执行别的子程序, 在适当的时候再返回来接着执行.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span>():</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span>():</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;x&#x27;</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">&#x27;y&#x27;</span></span><br></pre></td></tr></table></figure><p>假设由协程执行, 在执行A的过程中, 可以随时中断, 去执行B, B也可能在执行过程中中断再去执行A, 结果可能是: 1 2 x y 3<br><font color="red"><strong>协程的特点在于是一个线程执行, 那和多线程比, 协程有何优势?</strong></font>  </p><ul><li>线程的切换由操作系统调度, 协程由用户自己进行调度, 因此减少了上下文切换, 提到了效率</li><li>线程默认stack大小是1M, 而协程更轻量, 接近1K. 因此可以在相同的内存中开启更多的协程.</li><li>不需要多线程的锁机制: 因为只有一个线程, 也不存在同时写变量冲突, 在协程中控制共享资源不加锁, 只需要判断状态就好了, 所以执行效率比多线程高很多</li></ul><blockquote><p><strong>注意:</strong><br><font color="red">协程适用于被阻塞的, 且需要大量并发的场景(网络IO). 不适合大量计算的场景</font>  </p></blockquote><h3 id="Java线程的调度机制"><a href="#Java线程的调度机制" class="headerlink" title="Java线程的调度机制"></a>Java线程的调度机制</h3><p>线程调度是指系统为线程分配处理器使用权的过程, 主要调度方式分两种, 分别是协同式线程调度和抢占式线程调度  </p><h4 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h4><p><font color="red"><strong>线程执行时间由线程本身来控制</strong></font>, 线程把自己的工作执行完之后, 要主动通知系统切换到另一个线程上. 最大好处是实现简单, 且切换操作对线程自己是可知的, 没啥线程同步问题. 坏处是线程执行事件不可控制, 如果一个线程有问题, 可能一直阻塞在那里.  </p><h4 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h4><p><font color="red"><strong>每一个线程将由系统来分配执行时间, 线程的切换不由线程本身来决定</strong></font>(Java中, Thread.yield()可以让出执行时间, 但无法获取执行时间). 线程执行时间系统可控, 也不会有一个线程导致整个进程阻塞.  </p><h4 id="Java线程调度就是抢占式调度"><a href="#Java线程调度就是抢占式调度" class="headerlink" title="Java线程调度就是抢占式调度"></a>Java线程调度就是抢占式调度</h4><p>希望系统能给某些线程多分配一些时间, 给一些线程少分配一些时间, 可以通过设置线程优先级来完成. Java语言一共10个级别的线程优先级(Thread.MIN_PRIORITY至Thread.MAX_PRIORITY), 在两线程同时处于ready状态时, 优先级越高的线程越容易被系统选择执行. <font color="red">但优先级并不是很靠谱, 因为Java线程是通过映射到系统的原生线程上来实现的, 所以线程调度最终还是取决于操作系统</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 车票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SellTicketDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ticket = <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 线程进入暂时的休眠</span></span><br><span class="line">                        Thread.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取到当前正在执行的程序的名称，打印余票</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">&quot;:正在执行操作，余票:&quot;</span> + ticket--);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicketDemo demo = <span class="keyword">new</span> SellTicketDemo();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(demo,<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(demo,<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(demo,<span class="string">&quot;thread3&quot;</span>);</span><br><span class="line">        Thread thread4 = <span class="keyword">new</span> Thread(demo,<span class="string">&quot;thread4&quot;</span>);</span><br><span class="line">        <span class="comment">//priority优先级默认是5，最低1，最高10</span></span><br><span class="line">        thread1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        thread2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        thread3.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        thread4.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread4.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h3><p>Java 语言中线程共有六种状态, 分别是:  </p><ol><li>NEW(初始化状态)</li><li>RUNNABLE(可运行状态+运行状态)</li><li>BLOCKED(阻塞状态)</li><li>WAITING(无时限等待)</li><li>TIMED_WAITING(有时限等待)</li><li>TERMINATED(终止状态)</li></ol><p>在操作系统层面, Java 线程中的 <code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING</code> 是一种状态, 即前面我们提到的休眠状态. 也就是说只要 Java 线程处于这三种状态之一, 那么这个线程就永远没有 CPU 的使用权  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEB3f50ad1e0f0d1ab34e1242942c931a4f?method=download&shareKey=92db0504c982b561ff3a45ce8b5eea39" alt="avatar">  </p><p><strong>从JavaThread的角度, JVM定义了一些针对Java Thread对象的状态(jvm.h)</strong>  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBd6f143e465bdf25245ada06c9edbda6b?method=download&shareKey=9c6a86e956c86f478fc6374afa325765" alt="avatar">  </p><p><strong>从OSThread的角度, JVM还定义了一些线程状态给外部使用, 比如用jstack输出的线程堆栈信息中线程的状态(osThread.hpp)</strong>  </p><p><img src="https://note.youdao.com/yws/api/personal/file/WEBfd7887a2bbc160c0edc73361469dc705?method=download&shareKey=1297fc4d77eed8df4f660294b8d1ddd4" alt="avatar">  </p><h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><h4 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h4><ul><li>调用 sleep 会让当前线程从 Running 进入TIMED_WAITING状态, <strong>不会释放对象锁</strong></li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程, 这时 sleep 方法会抛出 InterruptedException, 并且会清除中断标志</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>sleep当传入参数为0时和yield相同</li></ul><h4 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h4><ul><li>yield会释放CPU资源, 让当前线程从 Running 进入 Runnable状态, 让优先级更高(至少是相同)的线程获得执行机会, <strong>不会释放对象锁</strong></li><li>假设当前进程只有main线程, 当调用yield之后, main线程会继续运行, 因为没有比它优先级更高的线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ul><h4 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h4><p>等待调用join方法的线程结束之后, 程序再继续执行, 一般用于等待异步线程执行完结果之后才能继续运行的场景  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] sure)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t begin&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t finished&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程等待线程t执行完成</span></span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;执行时间:&quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">        System.out.println(<span class="string">&quot;Main finished&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考: 如何正确优雅的停止线程?</p><h4 id="stop方法"><a href="#stop方法" class="headerlink" title="stop方法"></a>stop方法</h4><p>stop()方法已经被jdk废弃, 原因就是stop()方法太过于暴力, 强行把执行到一半的线程终止  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">60000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行完成&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="comment">// 停止thread，并释放锁</span></span><br><span class="line">        thread.stop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;等待获取锁&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>stop会释放对象锁, 可能会造成数据不一致</p><h3 id="Java线程的中断机制"><a href="#Java线程的中断机制" class="headerlink" title="Java线程的中断机制"></a>Java线程的中断机制</h3><p>Java没有提供一种安全、直接的方法来停止某个线程, 而是提供了中断机制. <font color="red">中断机制是一种协作机制, 也就是说通过中断并不能直接终止另一个线程, 而需要被中断的线程自己处理.</font> 被中断的线程拥有完全的自主权, 它既可以选择立即停止, 也可以选择一段时间后停止, 也可以选择压根不停止  </p><h4 id="API的使用"><a href="#API的使用" class="headerlink" title="API的使用"></a>API的使用</h4><ul><li>interrupt(): 将线程的中断标志位设置为true, 不会停止线程</li><li>isInterrupted(): 判断当前线程的中断标志位是否为true, 不会清除中断标志位</li><li>Thread.interrupted(): 判断当前线程的中断标志位是否为true, 并清除中断标志位, 重置为fasle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadInterruptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;begin&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="comment">//Thread.interrupted()  清除中断标志位</span></span><br><span class="line">                    <span class="comment">//Thread.currentThread().isInterrupted() 不会清除中断标志位</span></span><br><span class="line">                    <span class="keyword">if</span> (Thread.currentThread().isInterrupted() ) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">10</span>)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//不会停止线程t1,只会设置一个中断标志位 flag=true</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用中断机制优雅的停止线"><a href="#利用中断机制优雅的停止线" class="headerlink" title="利用中断机制优雅的停止线"></a>利用中断机制优雅的停止线</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count++);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程停止： stop thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> StopThread());</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">5</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意: 使用中断机制时一定要注意是否存在中断标志位被清除的情况</font>  </p><h4 id="sleep-期间能否感受到中断"><a href="#sleep-期间能否感受到中断" class="headerlink" title="sleep 期间能否感受到中断"></a>sleep 期间能否感受到中断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程停止： stop thread&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处于休眠中的线程被中断, <font color="red"><strong>线程是可以感受到中断信号的, 并且会抛出一个 InterruptedException 异常, 同时清除中断信号, 将中断标记位设置成 false</strong></font>. 这样就会导致while条件Thread.currentThread().isInterrupted()为false, 程序会在不满足count &lt; 1000这个条件时退出. 如果不在catch中重新手动添加中断信号, 不做任何处理, 就会屏蔽中断请求, 有可能导致线程无法正确停止  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">//重新设置线程中断状态为true</span></span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java线程间通信"><a href="#Java线程间通信" class="headerlink" title="Java线程间通信"></a>Java线程间通信</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile有两大特性, 一是<code>可见性</code>, 二是<code>有序性</code>, 禁止指令重排序, 其中可见性就是可以让线程之间进行通信  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;trun on&quot;</span>);</span><br><span class="line">                        flag = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;trun off&quot;</span>);</span><br><span class="line">                        flag = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待唤醒-等待通知-机制"><a href="#等待唤醒-等待通知-机制" class="headerlink" title="等待唤醒(等待通知)机制"></a>等待唤醒(等待通知)机制</h4><p>等待唤醒机制可以基于wait和notify方法来实现, 在一个线程内调用该线程锁对象的wait方法, 线程将进入等待队列进行等待直到被唤醒  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;wait start .......&quot;</span>);</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">&quot;wait end ....... &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                            lock.notify();</span><br><span class="line">                            System.out.println(<span class="string">&quot;notify .......&quot;</span>);</span><br><span class="line">                            flag = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">LockSupport是JDK中用来实现线程阻塞和唤醒的工具, 线程调用park则等待<code>许可</code>, 调用unpark则为指定线程提供<code>许可</code></font>. 使用它可以在任何场合使线程阻塞, 可以指定任何线程进行唤醒, 并且不用担心阻塞和唤醒操作的顺序, 但要注意连续多次唤醒的效果和一次唤醒是一样的  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupportTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread parkThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ParkThread());</span><br><span class="line">        parkThread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;唤醒parkThread&quot;</span>);</span><br><span class="line">        LockSupport.unpark(parkThread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParkThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ParkThread开始执行&quot;</span>);</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.println(<span class="string">&quot;ParkThread执行完成&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="管道输入输出流"><a href="#管道输入输出流" class="headerlink" title="管道输入输出流"></a>管道输入输出流</h4><p>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于, 它主要用于线程之间的数据传输, 而传输的媒介为内存. 管道输入/输出流主要包括了如下4种具体实现: <code>PipedOutputStream</code>、<code>PipedInputStream</code>、<code>PipedReader</code>和<code>PipedWriter</code>, 前两种面向字节, 而后两种面向字符  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Piped</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PipedWriter out = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">        PipedReader in = <span class="keyword">new</span> PipedReader();</span><br><span class="line">        <span class="comment">// 将输出流和输入流进行连接，否则在使用时会抛出IOException</span></span><br><span class="line">        out.connect(in);</span><br><span class="line"></span><br><span class="line">        Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Print(in), <span class="string">&quot;PrintThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">        printThread.start();</span><br><span class="line">        <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((receive = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(receive);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> PipedReader in;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(PipedReader in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.in = in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> receive = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> ((receive = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.print((<span class="keyword">char</span>) receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join"></a>Thread.join</h4><p>join可以理解成是线程合并, <font color="red">当在一个线程调用另一个线程的join方法时, 当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行, 所以join的好处能够保证线程的执行顺序</font>，但是如果调用线程的join方法其实已经失去了并行的意义, 虽然存在多个线程, 但是本质上还是串行的, 最后join的实现其实是基于等待通知机制的  </p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务捕获异常依旧回滚</title>
      <link href="/blogs/2021/01/25/Spring%E4%BA%8B%E5%8A%A1%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E4%BE%9D%E6%97%A7%E5%9B%9E%E6%BB%9A/"/>
      <url>/blogs/2021/01/25/Spring%E4%BA%8B%E5%8A%A1%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E4%BE%9D%E6%97%A7%E5%9B%9E%E6%BB%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>一段生产事故发人深省，在Spring的声明式事务中手动捕获异常，居然判定回滚了，这是什么操作？话不多说直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> C c;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b.insertB();</span><br><span class="line">            c.insertC();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BM bm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bm.insert(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CM cm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cm.insert(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>好了大家都看到上面这段代码了，在正常的情况的我们会往B表和C表中各插入一条数据，那么当代码出现异常时又会怎么样呢？</p><p>我们现在假设B插入数据成功，但是C插入数据失败了，此时异常会上抛到A，被A中<code>operate</code>方法的try - cache所捕获，正常来说此时数据库中B能插入一条记录，而C表插入失败，这是我们期望的情况，<font color="#cea5550">但事实却不是</font>，实际情况是B表没有插入数据，C表也没有插入数据，也就是说整个操作被Spring给回滚了</p><blockquote><p>注意点</p><p>如果代码稍稍变动一下，将try - cache放在<code>insertC</code>的代码块中，在同样的场景下，B中会成功插入一条记录</p></blockquote><h2 id="知识点前置条件"><a href="#知识点前置条件" class="headerlink" title="知识点前置条件"></a>知识点前置条件</h2><p>了解Spring的传播机制的可以直接跳过</p><blockquote><p>我们先要搞清楚Spring中的<code>REQUIRED</code>的作用</p><p>REQUIRED：如果当前没有事务就创建一个新的事务，如果当前已经存在事务就加入到当前事务</p><p>也就是说当我们的传播机制同时为<code>REQUIRED</code>时，A、B、C三者的事务是共用一个的，只有当A的流程全部走完时才会做一次commit或者rollback操作，不会在执行B或者C的过程中进行commit和rollback</p></blockquote><h2 id="问题追踪"><a href="#问题追踪" class="headerlink" title="问题追踪"></a>问题追踪</h2><p>好，有了一定的知识储备，我们一起来看源码</p><p>我们首先找到Spring事务的代理入口<code>TransactionInterceptor</code>, 当我们通过调用A类中的<code>operate</code>方法时会调用<code>TransactionInterceptor</code>的<code>invoke</code>方法，这是整个事务的入口，我们直接看重点<code>invoke</code>中的<code>invokeWithinTransaction</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取事务属性类 AnnotationTransactionAttributeSource</span></span><br><span class="line">TransactionAttributeSource tas = getTransactionAttributeSource();</span><br><span class="line"><span class="comment">//获取事务属性</span></span><br><span class="line"><span class="keyword">final</span> TransactionAttribute txAttr = (tas != <span class="keyword">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//获取事务管理器</span></span><br><span class="line"><span class="keyword">final</span> TransactionManager tm = determineTransactionManager(txAttr);</span><br><span class="line"></span><br><span class="line">PlatformTransactionManager ptm = asPlatformTransactionManager(tm);</span><br><span class="line"><span class="comment">//获取joinpoint</span></span><br><span class="line"><span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass, txAttr);</span><br><span class="line"><span class="comment">//注解事务会走这里</span></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line"><span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">TransactionInfo txInfo = createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// This is an around advice: Invoke the next interceptor in the chain.</span></span><br><span class="line"><span class="comment">// This will normally result in a target object being invoked.</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// target invocation exception</span></span><br><span class="line"><span class="comment">//事务回滚</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="keyword">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line"><span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">TransactionStatus status = txInfo.getTransactionStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="keyword">null</span> &amp;&amp; txAttr != <span class="keyword">null</span>) &#123;</span><br><span class="line">retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事务提交</span></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不重要的代码我已经省略了，好我们来看这个流程，上面这段代码很明显反应出了，当我们程序执行过程中抛出了异常时会调用到<code>completeTransactionAfterThrowing</code>的回滚操作，如果没有发生异常最终会调用事务提交<code>commitTransactionAfterReturning</code>， 我们来分析一下</p><p><img src="/blogs/img/transactionRequired.jpg" alt="img"></p><p>正常情况是C发生异常，并且执行到了<code>completeTransactionAfterThrowing</code>事务回滚，但是因为不是新创建的事务，而是加入的事务所以并不会触发回滚操作，而在A中捕获了该异常，并且最终走到<code>commitTransactionAfterReturning</code>事务提交，事实是这样的吗？</p><p>事实上就是这样的，那就奇怪了，我明明提交了，怎么反而回滚了，我们继续往下看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line">TransactionDefinition def = (definition != <span class="keyword">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点看.. DataSourceTransactionObject拿到对象</span></span><br><span class="line">Object transaction = doGetTransaction();</span><br><span class="line"><span class="keyword">boolean</span> debugEnabled = logger.isDebugEnabled();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一次进来connectionHolder为空的, 所以不存在事务</span></span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line"><span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line"><span class="comment">//如果不是第一次进来, 则会走这个逻辑</span></span><br><span class="line"><span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line"><span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> InvalidTimeoutException(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line"><span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一次进来大部分会走这里（传播属性是 Required ｜ Requested New ｜ Nested）</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line"><span class="comment">//先挂起</span></span><br><span class="line">SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line"><span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line"><span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(def, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是开启事务的代码，我们来看，当我们A第一次走进来的时候，此时是没有事务的，所以<code>isExistingTransaction</code>方法不成立，往下走，因为我们的传播机制是REQUIRED，所以我们会走到<code>startTransaction</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TransactionStatus <span class="title">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction, <span class="keyword">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line"><span class="comment">//创建一个新的事务状态, 注意这里的newTransaction 属性为true</span></span><br><span class="line">DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">doBegin(transaction, definition);</span><br><span class="line"><span class="comment">//开启事务后, 改变事务状态</span></span><br><span class="line">prepareSynchronization(status, definition);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好这里我们只需要关注一个点那就是<code>newTransactionStatus</code>的第三个参数<code>newTransaction</code>，只有当我们新创建一个事务的时候才会为<code>true</code>，<strong>这个属性很重要</strong>，我们后续还会用到它</p><p>好了，到这里第一次的事务开启就已经完成了，然后我们会调用业务逻辑，当调用insertB时，又会走到<code>getTransaction</code>，我们继续来看它，此时<code>isExistingTransaction</code>就可以拿到值了，因为A已经帮我们创建好了事务，此时会调用到<code>handleExistingTransaction</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果第二次进来还是PROPAFGATION_REQUIRED， 走这里, newTransation为false</span></span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="keyword">false</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>针对REQUIRED有用的代码就这一句，其他全部不用看，同样的我们看到第三个参数newTransaction，这里是false了，说明是加入了之前的事务，而不是自己新创建的，然后执行业务代码，最后走到commit，我们来看看commit中做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果有回滚点</span></span><br><span class="line"><span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Releasing transaction savepoint&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">status.releaseHeldSavepoint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是新事务, 则提交事务</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Initiating transaction commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">doCommit(status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">unexpectedRollback = status.isGlobalRollbackOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它什么事情都没有做，为什么？因为我们的<code>newTransaction</code>不为true，所以当我们的代码在<code>operate</code>方法全部执行完以后才会走到这里</p><p>好接下来我们来看<code>insertC</code>，前面的流程都一模一样，我们直接看到回滚代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRollback</span><span class="params">(DefaultTransactionStatus status, <span class="keyword">boolean</span> unexpected)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">boolean</span> unexpectedRollback = unexpected;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">triggerBeforeCompletion(status);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status.hasSavepoint()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Rolling back transaction to savepoint&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">status.rollbackToHeldSavepoint();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status.isNewTransaction()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Initiating transaction rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">doRollback(status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Participating in larger transaction</span></span><br><span class="line"><span class="keyword">if</span> (status.hasTransaction()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSetRollbackOnly(status);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (status.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Should roll back transaction but cannot - no transaction available&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unexpected rollback only matters here if we&#x27;re asked to fail early</span></span><br><span class="line"><span class="keyword">if</span> (!isFailEarlyOnGlobalRollbackOnly()) &#123;</span><br><span class="line">unexpectedRollback = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Raise UnexpectedRollbackException if we had a global rollback-only marker</span></span><br><span class="line"><span class="keyword">if</span> (unexpectedRollback) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnexpectedRollbackException(</span><br><span class="line"><span class="string">&quot;Transaction rolled back because it has been marked as rollback-only&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupAfterCompletion(status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的<code>insertC</code>方法同样它的newTransaction不是true，所以最终会走到<code>doSetRollbackOnly</code>，这个方法<strong>重中之重</strong>，最后会调用这样一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.rollbackOnly = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就要执行到我们的关键代码A中的<code>operate</code>的提交代码了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (status.isCompleted()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(<span class="string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Transactional code has requested rollback&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">processRollback(defStatus, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;</span><br><span class="line"><span class="keyword">if</span> (defStatus.isDebug()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">processRollback(defStatus, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行事务提交</span></span><br><span class="line">processCommit(defStatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，看到这大家都明白了吧，在commit中，Spring会去判断<code>defStatus.isGlobalRollbackOnly</code>有没有抛出过异常被Spring所拦截，如果有，那么就不会执行commit操作，转而执行<code>processRollback</code>回滚操作</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p><font color="#cea5550">在Spring的REQUIRED中，只要异常被Spring捕获到过，那么Spring最终就会回滚整个事务，即使自己在业务中已经捕获</font></p><p>所以我们回到最初的代码，如果我们希望Spring不进行回滚，那么我们只用将try-cache方法insertC方法中就可以，因为此时抛出的异常并不会被Spring所拦截到</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Spring循环依赖</title>
      <link href="/blogs/2021/01/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BASpring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/blogs/2021/01/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BASpring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>相信做Java开发的同学都知道什么是Spring，并且一直都在使用它，但是面对我们老生常谈的话题Spring 的循环依赖，也有不少人知道，可是真的让你去详细的说明时，又显得一知半解说不清楚，不用急，我们现在就来揭开循环依赖的神秘面纱</p><h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>所谓的循环依赖指的就是类与类之间的依赖关系形成了闭环，就会导致循环依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServiceA serviceA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这个例子就是一个典型的循环依赖，ServiceA的实例化需要依赖于ServiceB，而ServiceB又依赖于ServiceA，从而形成闭环</p><h2 id="几种循环依赖情况"><a href="#几种循环依赖情况" class="headerlink" title="几种循环依赖情况"></a>几种循环依赖情况</h2><p>在Spring中循环依赖主要有三种情况：</p><ul><li>基于构造器的方式进行依赖注入时产生的循环依赖</li><li>原型模式下Field的依赖注入</li><li>单例模式下Field的依赖注入</li></ul><blockquote><p>在Spring中只有第三种单例模式下的依赖注入是真正意义上的解决了循环依赖问题</p><p>如果硬要说其他的方式也能解决循环依赖，我不否认确实可以，我们来看下面这段代码（非本章讲解的重点，只是抛砖引玉，告诉大家循环依赖有多种处理方式）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceA</span><span class="params">(ServiceB serviceB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceB = serviceB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceB <span class="title">getServiceB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceB</span><span class="params">(ServiceA serviceA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceA = serviceA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceA <span class="title">getServiceA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过在任意一个构造函数上添加懒加载来解决循环依赖问题，运行结果如下：</p><p><img src="/blogs/img/loop1.jpg" alt="img"></p><h2 id="如何解决循环依赖"><a href="#如何解决循环依赖" class="headerlink" title="如何解决循环依赖"></a>如何解决循环依赖</h2><p>在Spring中解决循环依赖问题最主要的是通过后两层的缓存来处理</p><blockquote><p>先来看看Spring的缓存结构</p><ul><li>singletonObjects</li></ul><p>当Bean实例化结束以后才会放到当前缓存，随后的每次getBean操作都会调用到这里来获取Bean实例</p><ul><li>earlySingletonObjects</li></ul><p>只有正在创建中的Bean才会存在于当前缓存，解决第一个类引用替换为代理对象的场景</p><ul><li>singletonFactories</li></ul><p>提前存储暴露的实例的引用，从三级缓存中获取只会被调用一次，一旦获取到实例后就会添加到二级缓存</p></blockquote><h2 id="Spring调用流程"><a href="#Spring调用流程" class="headerlink" title="Spring调用流程"></a>Spring调用流程</h2><p>好了对循环依赖有了大致的概念以后，我们来看它是怎么处理的</p><ul><li><code>├─</code> getBean ① 实例化入口</li><li><code>│ ├─</code> doGetBean</li><li><code>│ │ ├─</code> getSingleton ② 查看缓存里是否有实例</li><li><code>│ │ ├─</code> getObjectForBeanInstance ③ 如果缓存有实例，直接返回实例</li><li><code>│ │ ├─</code> getSingletond ④ 缓存没有实例，创建实例</li><li><code>│ │ │ ├─</code> beforeSingletonCreation ⑤ 添加beanName到正在实例化的bean的set集合</li><li><code>│ │ │ ├─</code> createBean</li><li><code>│ │ │ │ ├─</code> doCreateBean ⑥ 执行创建实例</li><li><code>│ │ │ │ │ ├─</code> createBeanInstance ⑦ 创建实例过程</li><li><code>│ │ │ │ │ │ ├─</code> determineConstructorsFromBeanPostProcessors ⑧ 如果构造函数有@Autowired</li><li><code>│ │ │ │ │ │ │ ├─</code> autowireConstructor ⑨ 执行构造器实例过程不会走到步骤 ⑪</li><li><code>│ │ │ │ │ │ │ │ └─</code> getBean 返回 ① 实例化入口</li><li><code>│ │ │ │ │ ├─</code> applyMergedBeanDefinitionPostProcessors ⑩ 注解的搜集和装配过程</li><li><code>│ │ │ │ │ ├─</code> earlySingletonExposure ⑪ 暴露还没有完全实例化完成的 bean</li><li><code>│ │ │ │ │ ├─</code> addSingletonFactory ⑫ 将提前暴露的 bean，放到三级缓存</li><li><code>│ │ │ │ │ ├─</code> populateBean ⑬ 依赖注入</li><li><code>│ │ │ │ │ │ ├─</code> inject</li><li><code>│ │ │ │ │ │ │ ├─</code> AutowiredFieldElement.inject ⑭ 有@Autowired注解域的注入</li><li><code>│ │ │ │ │ │ │ │ └─</code> getBean 返回①实例化入口</li><li><code>│ │ │ │ │ │ │ ├─</code> AutowiredMethodElement.inject ⑭ 有@Autowired注解方法的注入</li><li><code>│ │ │ │ │ │ │ │ └─</code> getBean 返回①实例化入口</li><li><code>│ │ │ │ │ ├─</code> initializeBean ⑮ bean 实例化和IOC依赖注入完以后的增强处理过程</li><li><code>│ │ │ │ │ └─</code> registerDisposableBeanIfNecessary ⑮ bean 的销毁过程</li><li><code>│ │ │ ├─</code> afterSingletonCreation ⑯ 实例化完成，将beanName从正在实例化的bean的set集合中删除</li><li><code>│ │ │ └─</code> addSingleton ⑰ 创建完成后，将完全实例化后的bean 放到一级缓存</li></ul><p>好了，我们根据流程从上往下慢慢看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line"><span class="comment">//从一级缓存中获取单例对象</span></span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="comment">//判断当前Bean是否正在创建中, 也就是没有初始化完成</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="comment">//从二级缓存中获取单例对象</span></span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="comment">//allowEarlyReference允许bean提前暴露</span></span><br><span class="line"><span class="comment">//是否允许从singleFactories中通过getObject拿到对象</span></span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line"><span class="comment">//从三级缓存中获取对象工厂</span></span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//通过单例工厂获取单例bean</span></span><br><span class="line"><span class="comment">//会调用到getEarlyBeanReference方法</span></span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="comment">//从三级缓存移动到二级缓存</span></span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getSingleton非常简单，依次从三级缓存中查找Bean的实例，一级缓存没有就从二级缓存找，二级缓存没有就从三级缓存找，这里我们第一次进来，所以无法获取到数据，接着往下看</p><p>中间的不重要的代码全部跳过，我们直接来看关键部分，看到这个方法<code>doCreateBean</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (</span><br><span class="line">mbd.isSingleton() <span class="comment">//是否单例</span></span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">//是否允许提前暴露</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName) <span class="comment">//是否正在实例化</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加三级缓存</span></span><br><span class="line"><span class="comment">//从三级缓存中调用getObject方法时, 会调用getEarlyBeanReference</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码上下不重要的地方已经省略了，直接看这几行，首先它必须是一个单例模式初始化的Bean且允许提前暴露以及正在初始化，这个时候会将自己添加到三级缓存中，好我们看这个入参<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>,这个参数什么时候会调用到？</p><p>我们来理一遍流程 ServiceA初始化时会走到这里，接着往下依赖注入ServiceB，当ServiceB依赖注入A时，会在getSingleton中拿到三级缓存，而三级缓存则是调用<code>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</code>方法来获取ServiceA的实例</p><p>其实核心的代码块就这2段，接下来我们来看完整的流程图，完整的展示循环依赖的过程</p><p><img src="/blogs/img/loop2.jpg" alt="img"></p><p>至此大家对Spring 的循环依赖都有了一定了解了，那么我们继续往下走</p><h2 id="面试大拷问"><a href="#面试大拷问" class="headerlink" title="面试大拷问"></a>面试大拷问</h2><h3 id="1-二级缓存可不可以解决循环依赖问题"><a href="#1-二级缓存可不可以解决循环依赖问题" class="headerlink" title="1. 二级缓存可不可以解决循环依赖问题"></a>1. 二级缓存可不可以解决循环依赖问题</h3><p>首先对于这个问题，结论一定是否定的，否则Spring只用2级缓存就OK了，所以我们需要了解的是为什么二级缓存不行</p><p>好我们从两个方面来入手</p><ul><li>只采用一级缓存 和 二级缓存</li></ul><p>先来分析这种情况，首先我们要搞清楚，三级缓存中所存储的内容和二级缓存是不同的，二级缓存存的是Bean对象，而三级缓存则是一个工厂类，我们来看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一段就是核心代码，什么时候会走到这里？当A注入B，然后B再循环注入A的时候，走到getSingleton方法，从三级缓存中获取Bean的时候就会走到这里，那么这段代码做了什么？给大家来个场景就懂了</p><p>现在我在某个方法上注入了@Transaction的注解，此时生成的Bean实际是个代理对象，而在循环依赖过程中同样的也应该要生成这样一个代理对象，那么如果说我的三级缓存中存的是一个对象那么B中所注入的对象就与实际的A对象不一致了，因为A最终应该生成的是一个代理对象</p><p>因此仅仅采用一级缓存 和 二级缓存 是无法满足循环依赖的</p><ul><li>只采用一级缓存 和 三级缓存</li></ul><p>我们再来看一级缓存和三级缓存的情况，既然有了上面的铺垫，那就很容易理解了，如果我有多层的依赖关系，每次循环依赖到A都要从三级缓存中去拿，那么就会产生 生成的是一个代理对象的代理对象，可能有点绕，我来个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cacheable</span></span><br><span class="line"><span class="meta">@Transaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">b</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的@Cacheable会生成一次代理对象，在此基础之上@Transaction会再生成一层代理，所以，如果说只有使用三级缓存的话，就可能产生代理对象套代理对象的现象</p><h3 id="2-三级缓存的值是在什么时候填充的"><a href="#2-三级缓存的值是在什么时候填充的" class="headerlink" title="2. 三级缓存的值是在什么时候填充的"></a>2. 三级缓存的值是在什么时候填充的</h3><p>我们都知道获取三级缓存的地方是在getSingleton的时候，那么到底什么时候放的值</p><p>完整的代码在<code>AbstractAutowireCapableBeanFactory#doCreateBean</code>方法中，先说下这个方法干了什么事</p><ul><li>创建Bean实例</li><li>收集注解（@Autowired、@Value等）</li><li>Field填充</li><li>Aware、init-method等的调用</li><li>BeanPostProcessor的调用</li></ul><p>那么三级缓存的填充事发生在Bean的实例化以后，属性填充之前。</p><p>为什么是在这里进行填充，也很容易想明白，因为当进行属性填充的时候就会触发循环依赖，所以三级缓存的填充必须要在属性填充之前，而填充的值又必须已经存在，否则如何填充，因此又要在Bean的实例化之后</p><h3 id="3-如何知道当前Bean是否正在实例化"><a href="#3-如何知道当前Bean是否正在实例化" class="headerlink" title="3. 如何知道当前Bean是否正在实例化"></a>3. 如何知道当前Bean是否正在实例化</h3><p>Spring中会通过一个Set容器来把正在实例化的Bean的name放到容器中，触发时机是在第二次<code>getSingleton</code>的时候</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeSingletonCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>getSingleton</code>方法以后，调用<code>createBean</code>方法之前，会将BeanName放到Set（singletonsCurrentlyInCreation）容器中</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><ol><li>Spring的循环依赖只能作用于单例模式下的基于setter注入的方式</li><li>三级缓存是为了解决AOP增强而产生的代理对象</li><li>二级缓存是为了解决三级缓存中AOP增强而导致的重复代理现象</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Configuration和Component的区别</title>
      <link href="/blogs/2021/01/09/Configuration%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blogs/2021/01/09/Configuration%E5%92%8CComponent%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p>@Configuration 和 @Component是我们常用的2个注解，当2个注解作用于Config上都能够完成注入功能，今天我们要讨论的就是这两者之间的区别</p><h2 id="注解差异"><a href="#注解差异" class="headerlink" title="注解差异"></a>注解差异</h2><p>我们先从注解本身来看两者的区别:</p><p>从代码上不难看出@Configuration的本质也是一个@Component，只是基于它作了一些扩展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用差异"><a href="#应用差异" class="headerlink" title="应用差异"></a>应用差异</h2><p>光看注解我们并看不出有和区别，接下来我用2个例子来表述它们在应用过程中的具体差异</p><p>例1:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfig</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Demo <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DemoFactory <span class="title">demoFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DemoFactory demoFactory= <span class="keyword">new</span> DemoFactory();</span><br><span class="line">demoFactory.setDemo(demo());</span><br><span class="line"><span class="keyword">return</span> demoFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个测试类来进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AnnotationConfigApplicationContext applicationContext= <span class="keyword">new</span> AnnotationConfigApplicationContext(App.class);</span><br><span class="line">Demo demo= applicationContext.getBean(Demo.class);</span><br><span class="line">DemoFactory demoFactory= applicationContext.getBean(DemoFactory.class);</span><br><span class="line"></span><br><span class="line">System.out.println(demo.hashCode());</span><br><span class="line">System.out.println(demoFactory.getDemo().hashCode());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogs/img/configuration1.jpg" alt="img"><br>基于@Component注解的作用下 我们所拿到的值是不同的<br><img src="/blogs/img/configuration2.jpg" alt="img"><br>基于@Configuration注解的作用下 我们所拿到的值是相同的</p><p>同样的 我们再来看一段代码</p><p>例2:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">//@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2Config</span> </span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Demo2 <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Demo2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DemoFactory <span class="title">demoFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">DemoFactory demoFactory= <span class="keyword">new</span> DemoFactory();</span><br><span class="line">Demo2 demo2= demo2();</span><br><span class="line">demoFactory.setDemo3( (Demo3) demo2.getObject());</span><br><span class="line"><span class="keyword">return</span> demoFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Demo3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"><span class="keyword">return</span> Demo3.class;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类我就省略了和上面的一样</p><p>结论也是一样的</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过这2个例子我们来思考2个问题</p><blockquote><ol><li>为什么Configuration要这样设计，为什么它返回的结果是对象本身而Component确实一个新的对象</li><li>Configuration是如何来实现这个功能的</li></ol></blockquote><h3 id="我们先来思考第一个问题"><a href="#我们先来思考第一个问题" class="headerlink" title="我们先来思考第一个问题"></a>我们先来思考第一个问题</h3><p>我们都知道在Spring中有一个非常重要的思想那就是单例，在正常情况下我们的项目使用的都是单例来完成的，如果说使用Component的方式来完成那就违背了这一准则，说白了在实例化的时候，我们从Factory中获取出来的对象 和 Spring管理的Bean并不是同一个对象可以吗？显然是否定的，拿一个例子来说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是Spring装配Redis模版的代码，如果说我们对Redis的信息在connectionFactory发生了变化那么基于Component的方式它是无法感知到的，因为它们共用的并不是一个实体，所以以单例的方式拿到一个共享对象是非常重要的</p><h3 id="我们再来看看第二个问题"><a href="#我们再来看看第二个问题" class="headerlink" title="我们再来看看第二个问题"></a>我们再来看看第二个问题</h3><p>那么Spring到底是如何实现的，其实大家都不需要去想就能直接了当的说出答案<strong>代理</strong>，为什么呢？很显然当我们的类试图去拿被@Bean所装饰的方法时，它会先从缓存中去获取对象，这不就是一个典型的<strong>代理模式</strong>吗</p><p>不信？让我们来看看源码</p><p>首先我们需要了解@Configuration的注解Spring是在哪里进行处理的，从名字就能看出来当然是<strong>ConfigurationClassPostProcessor</strong>，好我们看到处理的方法<code>postProcessBeanFactory</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> factoryId = System.identityHashCode(beanFactory);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;postProcessBeanFactory already called on this post-processor against &quot;</span> + beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.factoriesPostProcessed.add(factoryId);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成代理对象</span></span><br><span class="line">enhanceConfigurationClasses(beanFactory);</span><br><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中有个非常醒目的方法<code>enhanceConfigurationClasses</code>，看名字就知道是cglib的动态代理</p><p>我们再来看看这个方法里面生成代理的类<strong>ConfigurationClassEnhancer</strong>，这个类中有个非常重要的方法<code>enhance</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; enhance(Class&lt;?&gt; configClass, <span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line"><span class="keyword">if</span> (EnhancedConfiguration.class.isAssignableFrom(configClass)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(String.format(<span class="string">&quot;Ignoring request to enhance %s as it has &quot;</span> +</span><br><span class="line"><span class="string">&quot;already been enhanced. This usually indicates that more than one &quot;</span> +</span><br><span class="line"><span class="string">&quot;ConfigurationClassPostProcessor has been registered (e.g. via &quot;</span> +</span><br><span class="line"><span class="string">&quot;&lt;context:annotation-config&gt;). This is harmless, but you may &quot;</span> +</span><br><span class="line"><span class="string">&quot;want check your configuration and remove one CCPP if possible&quot;</span>,</span><br><span class="line">configClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> configClass;</span><br><span class="line">&#125;</span><br><span class="line">Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(String.format(<span class="string">&quot;Successfully enhanced %s; enhanced class name is: %s&quot;</span>,</span><br><span class="line">configClass.getName(), enhancedClass.getName()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> enhancedClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; configSuperClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"><span class="comment">//需要增强的类，这边的configSuperClass实际上就是带有@Configuration注解的类</span></span><br><span class="line">enhancer.setSuperclass(configSuperClass);</span><br><span class="line">enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line"><span class="comment">//回调过滤器</span></span><br><span class="line">enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line"><span class="comment">//回调方法</span></span><br><span class="line">enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line"><span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是标准的cglib，对方法进行增强，这里补充一下Callback的回调方法总共有3个</p><ul><li>BeanMethodInterceptor</li></ul><p>对带有@Bean注解的方法的增强</p><ul><li>BeanFactoryAwareMethodInterceptor</li></ul><p>对实现了BeanFactoryAware接口的类中setBeanFactory方法的增强</p><ul><li>NoOp.INSTANCE</li></ul><p>不做任何处理</p><p>既然已经生成了代理，那么接下来就是在代理中作了哪些处理，让我们一起来看看<strong>BeanMethodInterceptor</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有当@Bean的方法是被Spring调到的时候, 才会走下来</span></span><br><span class="line"><span class="keyword">if</span> (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp; BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) &#123;</span><br><span class="line">logger.info(String.format(<span class="string">&quot;@Bean method %s.%s is non-static and returns an object &quot;</span> +</span><br><span class="line"><span class="string">&quot;assignable to Spring&#x27;s BeanFactoryPostProcessor interface. This will &quot;</span> +</span><br><span class="line"><span class="string">&quot;result in a failure to process annotations such as @Autowired, &quot;</span> +</span><br><span class="line"><span class="string">&quot;@Resource and @PostConstruct within the method&#x27;s declaring &quot;</span> +</span><br><span class="line"><span class="string">&quot;@Configuration class. Add the &#x27;static&#x27; modifier to this method to avoid &quot;</span> +</span><br><span class="line"><span class="string">&quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;</span>,</span><br><span class="line">beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用被代理方法</span></span><br><span class="line"><span class="keyword">return</span> cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用代理对象手动调用@Bean的方法的时候才会走下来</span></span><br><span class="line"><span class="keyword">return</span> resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br></pre></td></tr></table></figure><p>这里需要注意的是，我上面写的例子最终是不会走到这个<strong>isCurrentlyInvokedFactoryMethod</strong>条件里面去的，<del>为什么我就先不扩展了，大家如果感兴趣可以去看SimpleInstantiationStrategy#instantiate，如果看不懂可以私聊我</del>，所以我们关注的是这个<strong>resolveBeanReference</strong>方法，这个方法中 关键代码就一句从beanFactory中获取Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object beanInstance = (useArgs ? beanFactory.getBean(beanName, beanMethodArgs) : beanFactory.getBean(beanName));</span><br></pre></td></tr></table></figure><p>那么这个时候去拿，拿到的就是同一个实例</p><h2 id="细节决定成败"><a href="#细节决定成败" class="headerlink" title="细节决定成败"></a>细节决定成败</h2><ol><li>为什么createClass返回的是类的反射对象而不是类的实例？</li></ol><p>大家着重看上面<strong>ConfigurationClassEnhancer</strong>中的这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; enhancedClass = createClass(newEnhancer(configClass, classLoader));</span><br></pre></td></tr></table></figure><p><strong>因为这个类我们最终是需要交给Spring来进行管理，所以实例化的工作最终是交给Spring容器来做，而不是cglib来完成</strong></p><ol start="2"><li>isCurrentlyInvokedFactoryMethod(beanMethod)条件是怎么成立的？</li></ol><p>要搞清楚这个问题，我们首先要知道@Bean的对象是如何被Spring实例化的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果有FactoryMethodName属性 <span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> * 这个if成立条件只有2种情况:</span></span><br><span class="line"><span class="comment"> * 1. &lt;Bean&gt; 标签中配置了factory-method属性</span></span><br><span class="line"><span class="comment"> *  2. 方法上面加上了<span class="doctag">@Bean</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 反射的方式调用FactoryMethod</span></span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Spring去实例化Bean的时候会去判断BeanDefinition是否包含FactoryMethod如果是，就会在容器<strong>currentlyInvokedFactoryMethod</strong>中添加</p><p>而<strong>isCurrentlyInvokedFactoryMethod</strong>就是判断容器中的方法是否与目前正在调用的方法一致</p><ol start="3"><li>Spring是如何知道哪些对象需要生成代理对象，哪些不需要？</li></ol><p>这个问题要从2部分出发<strong>判断</strong>、<strong>收集</strong></p><p>我们先来看判断需要生成代理的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(beanDef <span class="keyword">instanceof</span> AbstractBeanDefinition)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Cannot enhance @Configuration bean definition &#x27;&quot;</span> +</span><br><span class="line">beanName + <span class="string">&quot;&#x27; since it is not stored in an AbstractBeanDefinition subclass&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (logger.isInfoEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">logger.info(<span class="string">&quot;Cannot enhance @Configuration bean definition &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; since its singleton instance has been created too early. The typical cause &quot;</span> +</span><br><span class="line"><span class="string">&quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot;</span> +</span><br><span class="line"><span class="string">&quot;return type: Consider declaring such methods as &#x27;static&#x27;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们回去判断标记是否为FULL，如果是就会装配进configBeanDefs，然后Spring就会循环configBeanDefs进行<code>enhance</code>增强</p><p>我们再来看Spring是在哪里打的标记（类的位置：ConfigurationClassPostProcessor#processConfigBeanDefinitions）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//获取所有的beanNames</span></span><br><span class="line">String[] candidateNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String beanName : candidateNames) &#123;</span><br><span class="line">BeanDefinition beanDef = registry.getBeanDefinition(beanName);</span><br><span class="line"><span class="comment">//如果有该表示就不再处理</span></span><br><span class="line"><span class="keyword">if</span> (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否是候选的需要处理的BeanDefinition, 如果是则放入configCandidates容器中</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="keyword">this</span>.metadataReaderFactory)) &#123;</span><br><span class="line">configCandidates.add(<span class="keyword">new</span> BeanDefinitionHolder(beanDef, beanName));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑在<strong>ConfigurationClassUtils.checkConfigurationClassCandidate</strong>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从metadata中获取Configuration注解</span></span><br><span class="line">Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line"><span class="comment">//如果有Configuration注解, 就是full匹配标识</span></span><br><span class="line"><span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !Boolean.FALSE.equals(config.get(<span class="string">&quot;proxyBeanMethods&quot;</span>))) &#123;</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是有Component、ComponentScan、Import、ImportResource或者方法上面有@Bean, 就是lite匹配</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (config != <span class="keyword">null</span> || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有的带有Configuration注解的类打上FULL标记</p><blockquote><p>触发时机</p><p>在AbstractApplicationContext的refresh方法中的invokeBeanFactoryPostProcessors方法，它的触发时机是在BeanDefinition初始化结束以后实例化之前完成，这里会去循环调用实现了BeanDefinitionRegistryPostProcessor接口的类</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
